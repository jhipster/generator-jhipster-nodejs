/* eslint-disable @typescript-eslint/no-unused-vars */
import { Entity, Column <%_ if (databaseType !== 'mongodb') { _%>, JoinColumn, OneToOne, ManyToOne, OneToMany, ManyToMany, JoinTable <%_ } _%> } from 'typeorm';
import { BaseEntity } from './base/base.entity';

<%_
let isUserRelationship = false;
const uniqueEntities = {};
const uniqueEnums = {};
const fieldsWithoutId = [];

for (idx in fields) {
    if (fields[idx].fieldIsEnum && (
            !uniqueEnums[fields[idx].fieldType] || (uniqueEnums[fields[idx].fieldType] && fields[idx].fieldValues.length !== 0))) {
        uniqueEnums[fields[idx].fieldType] = _.kebabCase(fields[idx].fieldType);
    }
    if (fields[idx].fieldName !== 'id') {
        fieldsWithoutId.push(fields[idx]);
    }
}
for (idx in relationships) {
    const relationship = relationships[idx];
    const otherEntityClass = asEntity(relationship.otherEntity.entityClass);
    if (relationship.otherEntity.entityClass === 'User'){
        isUserRelationship = true;
    }
    else if (!uniqueEntities[otherEntityClass] && otherEntityClass != asEntity(entityClass)) {
        uniqueEntities[otherEntityClass] = relationship.otherEntityFileName;
    }
}
_%>

<%_ Object.keys(uniqueEntities).forEach(function(entityClass) { _%>
import { <%= entityClass %> } from './<%= uniqueEntities[entityClass] %>.entity';
<%_ }); _%>
<%_ Object.keys(uniqueEnums).forEach(function(enumClass) { _%>
import { <%= enumClass %> } from './enumeration/<%= uniqueEnums[enumClass] %>';
<%_ }); _%>

<%_ if (isUserRelationship === true) { _%>
import { <%= asEntity('User') %> } from './user.entity';
<%_ } _%>

<%_ if (typeof javadoc == 'undefined') { _%>
/**
 * A <%= asEntity(entityClass) %>.
 */
<%_ } else { _%>
<%- formatAsClassJavadoc(javadoc) %>
<%_ } _%>
@Entity('<%= entityTableName %>')
export class <%= asEntity(entityClass) %> extends BaseEntity  {

<%_ for (idx in fieldsWithoutId) {
    const field = fieldsWithoutId[idx];
    if (typeof field.javadoc !== 'undefined') { _%>
<%- formatAsFieldJavadoc(field.javadoc) %>
    <%_ }
    let required = false;
    let unique = false;
    const fieldValidate = field.fieldValidate;
    const fieldValidateRules = field.fieldValidateRules;
    const fieldValidateRulesMaxlength = field.fieldValidateRulesMaxlength;
    const fieldType = field.fieldType;
    const fieldTypeBlobContent = field.fieldTypeBlobContent;
    const fieldName = field.fieldName;
    const fieldNameUnderscored = field.fieldNameUnderscored;
    const fieldNameAsDatabaseColumn = field.fieldNameAsDatabaseColumn;
    const fieldColumnType=addDbType(fieldType);
    if (fieldValidate === true) {
        if (fieldValidateRules.includes('required')) {
            required = true;
        }
        if (fieldValidateRules.includes('unique')) {
            unique = true;
        } _%>

    <%_ } _%>
        <%_ if (field.fieldIsEnum) { _%>
    @Column({type: 'simple-enum', name: '<%-fieldNameAsDatabaseColumn %>', enum: <%= fieldType %>})
        <%_ } else if (['Instant', 'ZonedDateTime', 'LocalDate'].includes(fieldType)) { _%>
    @Column({<%_ if(fieldColumnType) { _%> type: '<%-fieldColumnType%>' ,<%_ }_%> name: "<%-fieldNameAsDatabaseColumn %>"<% if (!required) { %>, nullable: true<% } %><% if (unique) { %>, unique: true<% } %>})
        <%_ } else if (fieldType === 'BigDecimal') { _%>
    @Column({<%_ if(fieldColumnType) { _%> type: '<%-fieldColumnType%>' ,<%_ }_%> name: "<%-fieldNameAsDatabaseColumn %>", precision : 10, scale : 2<% if (!required) { %>, nullable: true<% } %><% if (unique) { %>, unique: true<% } %>})
        <%_ } else { _%>
    @Column({<%_ if(fieldColumnType) { _%> type: '<%-fieldColumnType%>' ,<%_ }_%>  name: "<%-fieldNameAsDatabaseColumn %>"<% if (fieldValidate === true) { %><% if (fieldValidateRules.includes('maxlength')) { %>, length: <%= fieldValidateRulesMaxlength %><% } %> <% } %><% if (!required) { %>, nullable: true<% } %><% if (unique) { %>, unique: true<% }%>})
        <%_ } _%>
        <%_ if (field.fieldIsEnum) { _%>
    <%= fieldName %>: <%= fieldType %>;
        <%_ } else { _%>
    <%= fieldName %>: <%= getTsType(fieldType) %>;
        <%_ } _%>

    <%_ if ((fieldType === 'byte[]' || fieldType === 'ByteBuffer') && fieldTypeBlobContent !== 'text') { _%>
    @Column({name: '<%-fieldNameAsDatabaseColumn %>_content_type'<% if (!required) { %>, nullable: true<% } %>})
    <%= fieldName %>ContentType: string;
    <%_ }
    } _%>

    <%_
    for (idx in relationships) {
        const relationship = relationships[idx];
        const otherEntityRelationshipName = relationships[idx].otherEntityRelationshipName;
        const otherEntityRelationshipNamePlural = relationships[idx].otherEntityRelationshipNamePlural;
        const relationshipName = relationships[idx].relationshipName;
        const relationshipFieldName = relationships[idx].relationshipFieldName;
        const relationshipFieldNamePlural = relationships[idx].relationshipFieldNamePlural;
        const joinTableName = getJoinTableName(entityTableName, relationshipName, prodDatabaseType);
        const relationshipType = relationships[idx].relationshipType;
        const relationshipValidate = relationships[idx].relationshipValidate;
        const relationshipRequired = relationships[idx].relationshipRequired;
        const otherEntityNameCapitalized = relationships[idx].otherEntityNameCapitalized;
        const ownerSide = relationships[idx].ownerSide; // before was ownerSide === true in and userRel many-to-one
        const otherEntityClass = asEntity(relationships[idx].otherEntity.entityClass);
        let userRelationship = false;
        if (otherEntityClass === 'User'){
            userRelationship = true;
        }

        if (relationshipType === 'one-to-many') {_%>
    @OneToMany(type => <%= otherEntityClass %> <%_ if (userRelationship === false) { _%>, other => other.<%= otherEntityRelationshipName %><%_ } _%>)
    <%= relationshipFieldNamePlural %>: <%= otherEntityClass %>[];

    <%_ } else if (relationshipType === 'many-to-one') { _%>
    @ManyToOne(type => <%= otherEntityClass %> <%_ if (!ownerSide && userRelationship === false ) { _%>, other => other.<%= otherEntityRelationshipNamePlural %>  <%_ } _%>)
    <%= relationshipFieldName %>: <%= otherEntityClass %>;

    <%_ } else if (relationshipType === 'many-to-many') { _%>
    @ManyToMany(type => <%= otherEntityClass %> )
        <%_ if (ownerSide === true) { _%>
    @JoinTable({
        name: '<%= joinTableName %>',
        joinColumn: { name: '<%= getColumnName(name) %>_id', referencedColumnName: "id" },
        inverseJoinColumn: { name: '<%= getColumnName(relationship.relationshipName) %>_id', referencedColumnName: "id" }
    })
        <%_ } _%>
    <%= relationshipFieldNamePlural %>: <%= otherEntityClass %>[];

    <%_ } else { _%>
    @OneToOne(type => <%= otherEntityClass %>)
    <%_ if (ownerSide === true) { _%>@JoinColumn()<%_ } _%>
    <%= relationshipFieldName %>: <%= otherEntityClass %>;

    <%_ }
    } _%>
    // jhipster-needle-entity-add-field - JHipster will add fields here, do not remove

}
